/* automatically generated by rust-bindgen 0.66.1 */

pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 35;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const HARDENED_BOOL_TRUE: u32 = 1849;
pub const HARDENED_BOOL_FALSE: u32 = 468;
pub const HARDENED_BYTE_BOOL_TRUE: u32 = 165;
pub const HARDENED_BYTE_BOOL_FALSE: u32 = 75;
pub const _ASSERT_H: u32 = 1;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const _STRING_H: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const STATUS_BIT_ERROR: u32 = 31;
pub type __u_char = ::core::ffi::c_uchar;
pub type __u_short = ::core::ffi::c_ushort;
pub type __u_int = ::core::ffi::c_uint;
pub type __u_long = ::core::ffi::c_ulong;
pub type __int8_t = ::core::ffi::c_schar;
pub type __uint8_t = ::core::ffi::c_uchar;
pub type __int16_t = ::core::ffi::c_short;
pub type __uint16_t = ::core::ffi::c_ushort;
pub type __int32_t = ::core::ffi::c_int;
pub type __uint32_t = ::core::ffi::c_uint;
pub type __int64_t = ::core::ffi::c_long;
pub type __uint64_t = ::core::ffi::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::core::ffi::c_long;
pub type __u_quad_t = ::core::ffi::c_ulong;
pub type __intmax_t = ::core::ffi::c_long;
pub type __uintmax_t = ::core::ffi::c_ulong;
pub type __dev_t = ::core::ffi::c_ulong;
pub type __uid_t = ::core::ffi::c_uint;
pub type __gid_t = ::core::ffi::c_uint;
pub type __ino_t = ::core::ffi::c_ulong;
pub type __ino64_t = ::core::ffi::c_ulong;
pub type __mode_t = ::core::ffi::c_uint;
pub type __nlink_t = ::core::ffi::c_ulong;
pub type __off_t = ::core::ffi::c_long;
pub type __off64_t = ::core::ffi::c_long;
pub type __pid_t = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::core::ffi::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::core::mem::MaybeUninit<__fsid_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::core::ffi::c_long;
pub type __rlim_t = ::core::ffi::c_ulong;
pub type __rlim64_t = ::core::ffi::c_ulong;
pub type __id_t = ::core::ffi::c_uint;
pub type __time_t = ::core::ffi::c_long;
pub type __useconds_t = ::core::ffi::c_uint;
pub type __suseconds_t = ::core::ffi::c_long;
pub type __suseconds64_t = ::core::ffi::c_long;
pub type __daddr_t = ::core::ffi::c_int;
pub type __key_t = ::core::ffi::c_int;
pub type __clockid_t = ::core::ffi::c_int;
pub type __timer_t = *mut ::core::ffi::c_void;
pub type __blksize_t = ::core::ffi::c_long;
pub type __blkcnt_t = ::core::ffi::c_long;
pub type __blkcnt64_t = ::core::ffi::c_long;
pub type __fsblkcnt_t = ::core::ffi::c_ulong;
pub type __fsblkcnt64_t = ::core::ffi::c_ulong;
pub type __fsfilcnt_t = ::core::ffi::c_ulong;
pub type __fsfilcnt64_t = ::core::ffi::c_ulong;
pub type __fsword_t = ::core::ffi::c_long;
pub type __ssize_t = ::core::ffi::c_long;
pub type __syscall_slong_t = ::core::ffi::c_long;
pub type __syscall_ulong_t = ::core::ffi::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::core::ffi::c_char;
pub type __intptr_t = ::core::ffi::c_long;
pub type __socklen_t = ::core::ffi::c_uint;
pub type __sig_atomic_t = ::core::ffi::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::core::ffi::c_schar;
pub type int_fast16_t = ::core::ffi::c_long;
pub type int_fast32_t = ::core::ffi::c_long;
pub type int_fast64_t = ::core::ffi::c_long;
pub type uint_fast8_t = ::core::ffi::c_uchar;
pub type uint_fast16_t = ::core::ffi::c_ulong;
pub type uint_fast32_t = ::core::ffi::c_ulong;
pub type uint_fast64_t = ::core::ffi::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
extern "C" {
    pub fn __assert_fail(
        __assertion: *const ::core::ffi::c_char,
        __file: *const ::core::ffi::c_char,
        __line: ::core::ffi::c_uint,
        __function: *const ::core::ffi::c_char,
    ) -> !;
}
extern "C" {
    pub fn __assert_perror_fail(
        __errnum: ::core::ffi::c_int,
        __file: *const ::core::ffi::c_char,
        __line: ::core::ffi::c_uint,
        __function: *const ::core::ffi::c_char,
    ) -> !;
}
extern "C" {
    pub fn __assert(
        __assertion: *const ::core::ffi::c_char,
        __file: *const ::core::ffi::c_char,
        __line: ::core::ffi::c_int,
    ) -> !;
}
pub type wchar_t = ::core::ffi::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::core::ffi::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::core::mem::MaybeUninit<max_align_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::core::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OtSignConversionUnsupportedType {
    pub err: ::core::ffi::c_char,
}
#[test]
fn bindgen_test_layout_OtSignConversionUnsupportedType() {
    const UNINIT: ::core::mem::MaybeUninit<OtSignConversionUnsupportedType> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<OtSignConversionUnsupportedType>(),
        1usize,
        concat!("Size of: ", stringify!(OtSignConversionUnsupportedType))
    );
    assert_eq!(
        ::core::mem::align_of::<OtSignConversionUnsupportedType>(),
        1usize,
        concat!("Alignment of ", stringify!(OtSignConversionUnsupportedType))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).err) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OtSignConversionUnsupportedType),
            "::",
            stringify!(err)
        )
    );
}
#[doc = " The truthy value, expected to be used like #true."]
pub const hardened_bool_kHardenedBoolTrue: hardened_bool = 1849;
#[doc = " The falsey value, expected to be used like #false."]
pub const hardened_bool_kHardenedBoolFalse: hardened_bool = 468;
#[doc = " This is a boolean type for use in hardened contexts.\n\n The intention is that this is used instead of `<stdbool.h>`'s #bool, where a\n higher hamming distance is required between the truthy and the falsey value.\n\n The values below were chosen at random, with some specific restrictions. They\n have a Hamming Distance of 8, and they are 11-bit values so they can be\n materialized with a single instruction on RISC-V. They are also specifically\n not the complement of each other."]
pub type hardened_bool = ::core::ffi::c_uint;
#[doc = " This is a boolean type for use in hardened contexts.\n\n The intention is that this is used instead of `<stdbool.h>`'s #bool, where a\n higher hamming distance is required between the truthy and the falsey value.\n\n The values below were chosen at random, with some specific restrictions. They\n have a Hamming Distance of 8, and they are 11-bit values so they can be\n materialized with a single instruction on RISC-V. They are also specifically\n not the complement of each other."]
pub use self::hardened_bool as hardened_bool_t;
#[doc = " The truthy value."]
pub const hardened_byte_bool_kHardenedByteBoolTrue: hardened_byte_bool = 165;
#[doc = " The falsy value."]
pub const hardened_byte_bool_kHardenedByteBoolFalse: hardened_byte_bool = 75;
#[doc = " A byte-sized hardened boolean.\n\n This type is intended for cases where a byte-sized hardened boolean is\n required, e.g. for the entries of the `CREATOR_SW_CFG_SIGVERIFY_RSA_KEY_EN`\n OTP item.\n\n The values below were chosen to ensure that the hamming difference between\n them is greater than 5 and they are not bitwise complements of each other."]
pub type hardened_byte_bool = ::core::ffi::c_uint;
#[doc = " A byte-sized hardened boolean.\n\n This type is intended for cases where a byte-sized hardened boolean is\n required, e.g. for the entries of the `CREATOR_SW_CFG_SIGVERIFY_RSA_KEY_EN`\n OTP item.\n\n The values below were chosen to ensure that the hamming difference between\n them is greater than 5 and they are not bitwise complements of each other."]
pub use self::hardened_byte_bool as hardened_byte_bool_t;
#[doc = " A constant-time, 32-bit boolean value.\n\n Values of this type MUST be either all zero bits or all one bits,\n representing `false` and `true` respectively.\n\n Although it is possible to convert an existing `bool` into a `ct_bool32_t` by\n writing `-((ct_bool32_t) my_bool)`, we recommend against it"]
pub type ct_bool32_t = u32;
#[doc = " A constant-time, pointer-sized boolean value.\n\n Values of this type MUST be either all zero bits or all one bits."]
pub type ct_boolw_t = usize;
extern "C" {
    pub fn memcpy(
        __dest: *mut ::core::ffi::c_void,
        __src: *const ::core::ffi::c_void,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut ::core::ffi::c_void,
        __src: *const ::core::ffi::c_void,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut ::core::ffi::c_void,
        __src: *const ::core::ffi::c_void,
        __c: ::core::ffi::c_int,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut ::core::ffi::c_void,
        __c: ::core::ffi::c_int,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::core::ffi::c_void,
        __s2: *const ::core::ffi::c_void,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __memcmpeq(
        __s1: *const ::core::ffi::c_void,
        __s2: *const ::core::ffi::c_void,
        __n: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const ::core::ffi::c_void,
        __c: ::core::ffi::c_int,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_void;
}
extern "C" {
    pub fn strcpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strcat(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::core::ffi::c_ushort,
    pub __ctype_tolower: *const ::core::ffi::c_int,
    pub __ctype_toupper: *const ::core::ffi::c_int,
    pub __names: [*const ::core::ffi::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    const UNINIT: ::core::mem::MaybeUninit<__locale_struct> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__locales) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__ctype_b) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__ctype_tolower) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__ctype_toupper) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__names) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strcoll_l(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
        __l: locale_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strdup(__s: *const ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strndup(
        __string: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::core::ffi::c_char,
        __c: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::core::ffi::c_char,
        __c: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::core::ffi::c_char,
        __reject: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_ulong;
}
extern "C" {
    pub fn strspn(
        __s: *const ::core::ffi::c_char,
        __accept: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_ulong;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::core::ffi::c_char,
        __accept: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const ::core::ffi::c_char,
        __needle: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strtok(
        __s: *mut ::core::ffi::c_char,
        __delim: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut ::core::ffi::c_char,
        __delim: *const ::core::ffi::c_char,
        __save_ptr: *mut *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::core::ffi::c_char,
        __delim: *const ::core::ffi::c_char,
        __save_ptr: *mut *mut ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::core::ffi::c_char) -> ::core::ffi::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const ::core::ffi::c_char, __maxlen: usize) -> usize;
}
extern "C" {
    pub fn strerror(__errnum: ::core::ffi::c_int) -> *mut ::core::ffi::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::core::ffi::c_int,
        __buf: *mut ::core::ffi::c_char,
        __buflen: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strerror_l(__errnum: ::core::ffi::c_int, __l: locale_t) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const ::core::ffi::c_void,
        __s2: *const ::core::ffi::c_void,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn bcopy(__src: *const ::core::ffi::c_void, __dest: *mut ::core::ffi::c_void, __n: usize);
}
extern "C" {
    pub fn bzero(__s: *mut ::core::ffi::c_void, __n: ::core::ffi::c_ulong);
}
extern "C" {
    pub fn index(
        __s: *const ::core::ffi::c_char,
        __c: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn rindex(
        __s: *const ::core::ffi::c_char,
        __c: ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn ffs(__i: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ffsl(__l: ::core::ffi::c_long) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ffsll(__ll: ::core::ffi::c_longlong) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strcasecmp(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
        __loc: locale_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::core::ffi::c_char,
        __s2: *const ::core::ffi::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut ::core::ffi::c_void, __n: usize);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::core::ffi::c_char,
        __delim: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::core::ffi::c_int) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn stpcpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: usize,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut ::core::ffi::c_char,
        __src: *const ::core::ffi::c_char,
        __n: ::core::ffi::c_ulong,
    ) -> *mut ::core::ffi::c_char;
}
#[doc = " A field of a 32-bit bitfield.\n\n The following field definition: `{ .mask = 0b11, .index = 12 }`\n\n Denotes the X-marked bits in the following 32-bit bitfield:\n\n     field:  0b--------'--------'--XX----'--------\n     index:   31                                 0\n\n Restrictions: The index plus the width of the mask must not be greater than\n 31."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bitfield_field32 {
    #[doc = " The field mask. Usually all ones."]
    pub mask: u32,
    #[doc = " The field position in the bitfield, counting from the zero-bit."]
    pub index: u32,
}
#[test]
fn bindgen_test_layout_bitfield_field32() {
    const UNINIT: ::core::mem::MaybeUninit<bitfield_field32> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<bitfield_field32>(),
        8usize,
        concat!("Size of: ", stringify!(bitfield_field32))
    );
    assert_eq!(
        ::core::mem::align_of::<bitfield_field32>(),
        4usize,
        concat!("Alignment of ", stringify!(bitfield_field32))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bitfield_field32),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bitfield_field32),
            "::",
            stringify!(index)
        )
    );
}
#[doc = " A field of a 32-bit bitfield.\n\n The following field definition: `{ .mask = 0b11, .index = 12 }`\n\n Denotes the X-marked bits in the following 32-bit bitfield:\n\n     field:  0b--------'--------'--XX----'--------\n     index:   31                                 0\n\n Restrictions: The index plus the width of the mask must not be greater than\n 31."]
pub type bitfield_field32_t = bitfield_field32;
#[doc = " A single bit in a 32-bit bitfield.\n\n This denotes the position of a single bit, counting from the zero-bit.\n\n For instance, `(bitfield_bit_index_t)4` denotes the X-marked bit in the\n following 32-bit bitfield:\n\n     field:  0b--------'--------'--------'---X----\n     index:   31                                 0\n\n Restrictions: The value must not be greater than 31."]
pub type bitfield_bit32_index_t = u32;
#[doc = " 4-bits boolean values"]
pub const multi_bit_bool_kMultiBitBool4True: multi_bit_bool = 6;
#[doc = " 4-bits boolean values"]
pub const multi_bit_bool_kMultiBitBool4False: multi_bit_bool = 9;
#[doc = " 8-bits boolean values"]
pub const multi_bit_bool_kMultiBitBool8True: multi_bit_bool = 150;
#[doc = " 8-bits boolean values"]
pub const multi_bit_bool_kMultiBitBool8False: multi_bit_bool = 105;
#[doc = " 12-bits boolean values"]
pub const multi_bit_bool_kMultiBitBool12True: multi_bit_bool = 1686;
#[doc = " 12-bits boolean values"]
pub const multi_bit_bool_kMultiBitBool12False: multi_bit_bool = 2409;
#[doc = " 16-bits boolean values"]
pub const multi_bit_bool_kMultiBitBool16True: multi_bit_bool = 38550;
#[doc = " 16-bits boolean values"]
pub const multi_bit_bool_kMultiBitBool16False: multi_bit_bool = 26985;
#[doc = " Multi-bit boolean values\n\n Certain configuration fields in the design are multi-bits.\n This gives the configuration fields redundancy and ensures\n it is difficult to fault the values to a \"good\" state."]
pub type multi_bit_bool = ::core::ffi::c_uint;
#[doc = " Multi-bit boolean values\n\n Certain configuration fields in the design are multi-bits.\n This gives the configuration fields redundancy and ensures\n it is difficult to fault the values to a \"good\" state."]
pub use self::multi_bit_bool as multi_bit_bool_t;
pub const absl_status_code_kOk: absl_status_code = 0;
pub const absl_status_code_kCancelled: absl_status_code = 1;
pub const absl_status_code_kUnknown: absl_status_code = 2;
pub const absl_status_code_kInvalidArgument: absl_status_code = 3;
pub const absl_status_code_kDeadlineExceeded: absl_status_code = 4;
pub const absl_status_code_kNotFound: absl_status_code = 5;
pub const absl_status_code_kAlreadyExists: absl_status_code = 6;
pub const absl_status_code_kPermissionDenied: absl_status_code = 7;
pub const absl_status_code_kResourceExhausted: absl_status_code = 8;
pub const absl_status_code_kFailedPrecondition: absl_status_code = 9;
pub const absl_status_code_kAborted: absl_status_code = 10;
pub const absl_status_code_kOutOfRange: absl_status_code = 11;
pub const absl_status_code_kUnimplemented: absl_status_code = 12;
pub const absl_status_code_kInternal: absl_status_code = 13;
pub const absl_status_code_kUnavailable: absl_status_code = 14;
pub const absl_status_code_kDataLoss: absl_status_code = 15;
pub const absl_status_code_kUnauthenticated: absl_status_code = 16;
pub const absl_status_code_kDoNotUseReservedForFutureExpansionUseDefaultInSwitchInstead_:
    absl_status_code = 20;
#[doc = " This enum was taken directly from the abseil-cpp library:\n https://github.com/abseil/abseil-cpp/blob/master/absl/status/status.h\n\n These error codes serve as general error classifications which are used to\n build up more specific error codes.\n\n DO NOT USE THESE CODES DIRECTLY. Use these codes to build per-module error\n codes in error.h.  Although these error codes are generally used at\n Google by RPC servers, the advice about how to use them and how to\n categorize errors is generally sound."]
pub type absl_status_code = ::core::ffi::c_uint;
#[doc = " This enum was taken directly from the abseil-cpp library:\n https://github.com/abseil/abseil-cpp/blob/master/absl/status/status.h\n\n These error codes serve as general error classifications which are used to\n build up more specific error codes.\n\n DO NOT USE THESE CODES DIRECTLY. Use these codes to build per-module error\n codes in error.h.  Although these error codes are generally used at\n Google by RPC servers, the advice about how to use them and how to\n categorize errors is generally sound."]
pub use self::absl_status_code as absl_status_t;
#[doc = " Indicates that the operation succeeded."]
pub const dif_result_kDifOk: dif_result = 0;
#[doc = " Indicates some unspecified failure."]
pub const dif_result_kDifError: dif_result = 13;
#[doc = " Indicates that some parameter passed into a function failed a\n precondition.\n\n When this value is returned, no hardware operations occurred."]
pub const dif_result_kDifBadArg: dif_result = 3;
#[doc = " The operation failed because writes to a required register are\n disabled."]
pub const dif_result_kDifLocked: dif_result = 9;
#[doc = " The operation failed because the IP is processing an operation, and will\n finish in some amount of time. A function that returns this error may be\n retried at any time, and is guaranteed to have not produced any side\n effects."]
pub const dif_result_kDifUnavailable: dif_result = 14;
#[doc = " Indicates that the Ip's FIFO (if it has one or more of) is full."]
pub const dif_result_kDifIpFifoFull: dif_result = 8;
#[doc = " Indicates that the attempted operation would attempt a read/write to an\n address that would go out of range."]
pub const dif_result_kDifOutOfRange: dif_result = 11;
#[doc = " Indicates that the attempted operation would attempt a read/write to an\n address that is not aligned."]
pub const dif_result_kDifUnaligned: dif_result = 12;
#[doc = " The result of a DIF operation.\n\n NOTE: additional result values can be defined in the manually-implemented\n header by creating an additional *_result_t enum type. See the Lifecycle\n Controller DIF for how this may be implemented."]
pub type dif_result = ::core::ffi::c_uint;
#[doc = " The result of a DIF operation.\n\n NOTE: additional result values can be defined in the manually-implemented\n header by creating an additional *_result_t enum type. See the Lifecycle\n Controller DIF for how this may be implemented."]
pub use self::dif_result as dif_result_t;
#[doc = " The \"disabled\" state."]
pub const dif_toggle_kDifToggleDisabled: dif_toggle = 0;
#[doc = " The \"enabled\" state."]
pub const dif_toggle_kDifToggleEnabled: dif_toggle = 1;
#[doc = " A toggle state: enabled, or disabled.\n\n This enum may be used instead of a `bool` when describing an enabled/disabled\n state."]
pub type dif_toggle = ::core::ffi::c_uint;
#[doc = " A toggle state: enabled, or disabled.\n\n This enum may be used instead of a `bool` when describing an enabled/disabled\n state."]
pub use self::dif_toggle as dif_toggle_t;
#[doc = " Event type interrupt."]
pub const dif_irq_type_kDifIrqTypeEvent: dif_irq_type = 0;
#[doc = " Status type interrupt."]
pub const dif_irq_type_kDifIrqTypeStatus: dif_irq_type = 1;
#[doc = " An interrupt type: event, or status.\n\n This enum may be used instead when describing an interrupt type.\n Specifically, event interrupts require software to manually clear them by\n writing to the interrupt status register (after handling the root cause),\n while status interrupts clear immediately when the root cause of the iterrupt\n has been handled."]
pub type dif_irq_type = ::core::ffi::c_uint;
#[doc = " An interrupt type: event, or status.\n\n This enum may be used instead when describing an interrupt type.\n Specifically, event interrupts require software to manually clear them by\n writing to the interrupt status register (after handling the root cause),\n while status interrupts clear immediately when the root cause of the iterrupt\n has been handled."]
pub use self::dif_irq_type as dif_irq_type_t;
pub const module__kModuleUnknown: module_ = 0;
pub const module__kModuleAlertHandler: module_ = 16712;
pub const module__kModuleSigverify: module_ = 21334;
pub const module__kModuleKeymgr: module_ = 19277;
pub const module__kModuleManifest: module_ = 19777;
pub const module__kModuleRom: module_ = 19794;
pub const module__kModuleInterrupt: module_ = 18770;
pub const module__kModuleEpmp: module_ = 17744;
pub const module__kModuleKmac: module_ = 19267;
pub const module__kModuleOtbn: module_ = 16974;
pub const module__kModuleFlashCtrl: module_ = 17987;
pub const module__kModuleBootPolicy: module_ = 16976;
pub const module__kModuleBootstrap: module_ = 16979;
pub const module__kModuleLog: module_ = 19527;
pub const module__kModuleBootData: module_ = 16964;
pub const module__kModuleSpiDevice: module_ = 21328;
pub const module__kModuleAst: module_ = 16723;
pub const module__kModuleRstmgr: module_ = 21075;
pub const module__KModuleRnd: module_ = 21070;
pub type module_ = ::core::ffi::c_uint;
pub const rom_error_kErrorOk: rom_error = 1849;
pub const rom_error_kErrorUnknown: rom_error = 4294967295;
pub const rom_error_kErrorSigverifyBadRsaSignature: rom_error = 22238723;
pub const rom_error_kErrorSigverifyBadSpxSignature: rom_error = 39015939;
pub const rom_error_kErrorSigverifyBadKey: rom_error = 55793155;
pub const rom_error_kErrorSigverifyBadRsaKey: rom_error = 72570371;
pub const rom_error_kErrorSigverifyBadSpxKey: rom_error = 89347587;
pub const rom_error_kErrorSigverifyLargeRsaSignature: rom_error = 106124803;
pub const rom_error_kErrorKeymgrInternal: rom_error = 21712141;
pub const rom_error_kErrorManifestBadEntryPoint: rom_error = 21840141;
pub const rom_error_kErrorManifestBadCodeRegion: rom_error = 38617357;
pub const rom_error_kErrorManifestBadSignedRegion: rom_error = 55394573;
pub const rom_error_kErrorManifestBadExtension: rom_error = 72171789;
pub const rom_error_kErrorManifestBadVersionMajor: rom_error = 88949005;
pub const rom_error_kErrorAlertBadIndex: rom_error = 21055491;
pub const rom_error_kErrorAlertBadClass: rom_error = 37832707;
pub const rom_error_kErrorAlertBadEnable: rom_error = 54609923;
pub const rom_error_kErrorAlertBadEscalation: rom_error = 71387139;
pub const rom_error_kErrorAlertBadCrc32: rom_error = 88164355;
pub const rom_error_kErrorRomBootFailed: rom_error = 21844489;
pub const rom_error_kErrorInterrupt: rom_error = 4805122;
pub const rom_error_kErrorEpmpBadCheck: rom_error = 21319693;
pub const rom_error_kErrorKmacInvalidStatus: rom_error = 21709581;
pub const rom_error_kErrorOtbnInvalidArgument: rom_error = 21122563;
pub const rom_error_kErrorOtbnBadOffsetLen: rom_error = 37899779;
pub const rom_error_kErrorOtbnExecutionFailed: rom_error = 54677005;
pub const rom_error_kErrorOtbnSecWipeImemFailed: rom_error = 71454221;
pub const rom_error_kErrorOtbnSecWipeDmemFailed: rom_error = 88231437;
pub const rom_error_kErrorOtbnBadInsnCount: rom_error = 105008653;
pub const rom_error_kErrorOtbnUnavailable: rom_error = 121785869;
pub const rom_error_kErrorFlashCtrlDataRead: rom_error = 21381901;
pub const rom_error_kErrorFlashCtrlInfoRead: rom_error = 38159117;
pub const rom_error_kErrorFlashCtrlDataWrite: rom_error = 54936333;
pub const rom_error_kErrorFlashCtrlInfoWrite: rom_error = 71713549;
pub const rom_error_kErrorFlashCtrlDataErase: rom_error = 88490765;
pub const rom_error_kErrorFlashCtrlInfoErase: rom_error = 105267981;
pub const rom_error_kErrorFlashCtrlDataEraseVerify: rom_error = 122045197;
pub const rom_error_kErrorBootPolicyBadIdentifier: rom_error = 21123085;
pub const rom_error_kErrorBootPolicyBadLength: rom_error = 37900301;
pub const rom_error_kErrorBootPolicyRollback: rom_error = 54677517;
pub const rom_error_kErrorBootstrapEraseAddress: rom_error = 21123843;
pub const rom_error_kErrorBootstrapProgramAddress: rom_error = 37901059;
pub const rom_error_kErrorBootstrapInvalidState: rom_error = 54678275;
pub const rom_error_kErrorBootstrapNotRequested: rom_error = 71455501;
pub const rom_error_kErrorLogBadFormatSpecifier: rom_error = 21776141;
pub const rom_error_kErrorBootDataNotFound: rom_error = 21120013;
pub const rom_error_kErrorBootDataWriteCheck: rom_error = 37897229;
pub const rom_error_kErrorBootDataInvalid: rom_error = 54674445;
pub const rom_error_kErrorSpiDevicePayloadOverflow: rom_error = 22237197;
pub const rom_error_kErrorAstInitNotDone: rom_error = 21058317;
pub const rom_error_kErrorRstmgrBadInit: rom_error = 22172429;
pub const rom_error_kErrorRndBadCrc32: rom_error = 22171139;
#[doc = " Unified set of errors for ROM and ROM_EXT."]
pub type rom_error = ::core::ffi::c_uint;
#[doc = " Unified set of errors for ROM and ROM_EXT."]
pub use self::rom_error as rom_error_t;
#[doc = " We use the error category codes from absl_status.h.  We build a packed\n status value that identifies the source of the error (in the form of the\n module identifier and line number).\n\n By default, the module identifier is the first three letters of the\n source filename.  The identifier can be overridden (per-module) with the\n DECLARE_MODULE_ID macro.\n\n Our status codes are arranged as a packed bitfield, with the sign\n bit signifying whether the value represents a result or an error.\n\n All Ok (good) values:\n 32  31                                             0\n  +---+---------------------------------------------+\n  |   |                  31 bit                     |\n  | 0 |                  Result                     |\n  +---+---------------------------------------------+\n\n All Error values:\n 32  31      26      21      16             5       0\n  +---+-------+-------+-------+-------------+-------+\n  |   |   15 bit              | 11 bit      | 5 bit |\n  | 1 |   Module Identifier   | Line Number | code  |\n  +---+-------+-------+-------+-------------+-------+\n\n The module identifier value is interpreted as three 5-bit fields\n representing the characters [0x40..0x5F] (e.g. [@ABC ... _])."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct status {
    pub value: i32,
}
#[test]
fn bindgen_test_layout_status() {
    const UNINIT: ::core::mem::MaybeUninit<status> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<status>(),
        4usize,
        concat!("Size of: ", stringify!(status))
    );
    assert_eq!(
        ::core::mem::align_of::<status>(),
        4usize,
        concat!("Alignment of ", stringify!(status))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(status),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " We use the error category codes from absl_status.h.  We build a packed\n status value that identifies the source of the error (in the form of the\n module identifier and line number).\n\n By default, the module identifier is the first three letters of the\n source filename.  The identifier can be overridden (per-module) with the\n DECLARE_MODULE_ID macro.\n\n Our status codes are arranged as a packed bitfield, with the sign\n bit signifying whether the value represents a result or an error.\n\n All Ok (good) values:\n 32  31                                             0\n  +---+---------------------------------------------+\n  |   |                  31 bit                     |\n  | 0 |                  Result                     |\n  +---+---------------------------------------------+\n\n All Error values:\n 32  31      26      21      16             5       0\n  +---+-------+-------+-------+-------------+-------+\n  |   |   15 bit              | 11 bit      | 5 bit |\n  | 1 |   Module Identifier   | Line Number | code  |\n  +---+-------+-------+-------+-------------+-------+\n\n The module identifier value is interpreted as three 5-bit fields\n representing the characters [0x40..0x5F] (e.g. [@ABC ... _])."]
pub type status_t = status;
extern "C" {
    #[doc = " Report an error status.\n\n This header does not specify how the error is\n reported, or if it reported at all. Since status_t encodes the location\n of an error, this provides the infrastructure for a lightweight\n \"stack trace\"."]
    pub fn status_report(value: status_t);
}
extern "C" {
    pub static MODULE_ID: u32;
}
extern "C" {
    #[doc = " Creates a packed status_t.\n\n @param code An absl_status code.\n @param mod_id The module creating the status code.\n @param file The filename of the module creating the code.\n @param arg The argument associated with the status.\n @return `status_t`."]
    pub fn status_create(
        code: absl_status_t,
        mod_id: u32,
        file: *const ::core::ffi::c_char,
        arg: i32,
    ) -> status_t;
}
extern "C" {
    #[doc = " Extracts the packed values from a status code.\n\n @param s The status code to extract values from.\n @param code Pointer to the english name of the status code.\n @param arg Pointer to an integer argument.\n @param mod_id Pointer to a char[3] buffer for the module id.\n @return True if the status represents and error, False if the status\n represents Ok."]
    pub fn status_extract(
        s: status_t,
        code: *mut *const ::core::ffi::c_char,
        arg: *mut i32,
        mod_id: *mut ::core::ffi::c_char,
    ) -> bool;
}
#[doc = " Enum to handle return values of the crypto API.\n\n Values are built to be bit-compatible with OpenTitan's internal `status_t`\n datatypes. The highest (sign) bit indicates if the value is an error (1) or\n not (0). For non-error statuses, the rest can be anything; in cryptolib\n status codes it is always `kHardenedBoolTrue`. For errors:\n   - The next 15 bits are a module identifier, which is always 0 in the\n     cryptolib status codes\n   - The next 11 bits are a line number or other information; in the\n     cryptolib status codes, it is a hardened value created to have high\n     Hamming distance with the other valid status codes\n   - The final 5 bits are an Abseil-compatible error code\n\n The hardened values for error codes were generated with:\n $ ./util/design/sparse-fsm-encode.py -d 5 -m 5 -n 11 \\\n      -s 4232058530 --language=sv --avoid-zero\n\n Use the same seed value and a larger `-m` argument to generate new values\n without changing all error codes. Remove the seed (-s argument) to generate\n completely new 11-bit values."]
pub type crypto_status_t = status_t;
pub const crypto_status_value_kCryptoStatusOK: crypto_status_value = 1849;
pub const crypto_status_value_kCryptoStatusBadArgs: crypto_status_value = -2147418461;
pub const crypto_status_value_kCryptoStatusInternalError: crypto_status_value = -2147462326;
pub const crypto_status_value_kCryptoStatusFatalError: crypto_status_value = -2147455607;
pub const crypto_status_value_kCryptoStatusAsyncIncomplete: crypto_status_value = -2147423666;
pub const crypto_status_value_kCryptoStatusNotImplemented: crypto_status_value = -2147447508;
pub type crypto_status_value = ::core::ffi::c_int;
pub use self::crypto_status_value as crypto_status_value_t;
#[doc = " Struct to handle crypto data buffer with pointer and length.\n Note: If the crypto_uint8_buf_t is used for output data, it is\n expected that the user (1) sets the length of the expected output\n in the `len` field, and (2) allocates the required space for buffer\n (`len` bytes). If the output length set by the user doesn’t match\n the generated output length, an error is thrown and code exits."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypto_uint8_buf {
    pub data: *mut u8,
    pub len: usize,
}
#[test]
fn bindgen_test_layout_crypto_uint8_buf() {
    const UNINIT: ::core::mem::MaybeUninit<crypto_uint8_buf> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<crypto_uint8_buf>(),
        16usize,
        concat!("Size of: ", stringify!(crypto_uint8_buf))
    );
    assert_eq!(
        ::core::mem::align_of::<crypto_uint8_buf>(),
        8usize,
        concat!("Alignment of ", stringify!(crypto_uint8_buf))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_uint8_buf),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_uint8_buf),
            "::",
            stringify!(len)
        )
    );
}
#[doc = " Struct to handle crypto data buffer with pointer and length.\n Note: If the crypto_uint8_buf_t is used for output data, it is\n expected that the user (1) sets the length of the expected output\n in the `len` field, and (2) allocates the required space for buffer\n (`len` bytes). If the output length set by the user doesn’t match\n the generated output length, an error is thrown and code exits."]
pub type crypto_uint8_buf_t = crypto_uint8_buf;
#[doc = " Struct to handle crypto const data buffer with pointer and length."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypto_const_uint8_buf {
    pub data: *const u8,
    pub len: usize,
}
#[test]
fn bindgen_test_layout_crypto_const_uint8_buf() {
    const UNINIT: ::core::mem::MaybeUninit<crypto_const_uint8_buf> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<crypto_const_uint8_buf>(),
        16usize,
        concat!("Size of: ", stringify!(crypto_const_uint8_buf))
    );
    assert_eq!(
        ::core::mem::align_of::<crypto_const_uint8_buf>(),
        8usize,
        concat!("Alignment of ", stringify!(crypto_const_uint8_buf))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_const_uint8_buf),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_const_uint8_buf),
            "::",
            stringify!(len)
        )
    );
}
#[doc = " Struct to handle crypto const data buffer with pointer and length."]
pub type crypto_const_uint8_buf_t = crypto_const_uint8_buf;
pub const key_type_kKeyTypeAes: key_type = 46367;
pub const key_type_kKeyTypeHmac: key_type = 6507;
pub const key_type_kKeyTypeKmac: key_type = 59241;
pub const key_type_kKeyTypeRsa: key_type = 20404;
pub const key_type_kKeyTypeEcc: key_type = 15062;
pub const key_type_kKeyTypeKdf: key_type = 63873;
#[doc = " Enum to denote the key type of the handled key.\n\n Values are hardened."]
pub type key_type = ::core::ffi::c_uint;
#[doc = " Enum to denote the key type of the handled key.\n\n Values are hardened."]
pub use self::key_type as key_type_t;
pub const aes_key_mode_kAesKeyModeEcb: aes_key_mode = 55767;
pub const aes_key_mode_kAesKeyModeCbc: aes_key_mode = 53100;
pub const aes_key_mode_kAesKeyModeCfb: aes_key_mode = 37498;
pub const aes_key_mode_kAesKeyModeOfb: aes_key_mode = 25247;
pub const aes_key_mode_kAesKeyModeCtr: aes_key_mode = 62689;
pub const aes_key_mode_kAesKeyModeGcm: aes_key_mode = 15630;
pub const aes_key_mode_kAesKeyModeKwp: aes_key_mode = 11249;
#[doc = " Enum to specify the AES modes that use a key.\n\n This will be used in the `key_mode_t` struct to indicate the mode\n for which the provided key is intended for.\n\n Values are hardened."]
pub type aes_key_mode = ::core::ffi::c_uint;
#[doc = " Enum to specify the AES modes that use a key.\n\n This will be used in the `key_mode_t` struct to indicate the mode\n for which the provided key is intended for.\n\n Values are hardened."]
pub use self::aes_key_mode as aes_key_mode_t;
pub const hmac_key_mode_kHmacKeyModeSha256: hmac_key_mode = 25841;
#[doc = " Enum to specify the HMAC modes that use a key.\n\n This will be used in the `key_mode_t` struct to indicate the mode\n for which the provided key is intended for.\n\n Values are hardened."]
pub type hmac_key_mode = ::core::ffi::c_uint;
#[doc = " Enum to specify the HMAC modes that use a key.\n\n This will be used in the `key_mode_t` struct to indicate the mode\n for which the provided key is intended for.\n\n Values are hardened."]
pub use self::hmac_key_mode as hmac_key_mode_t;
pub const kmac_key_mode_kKmacKeyModeKmac128: kmac_key_mode = 56910;
pub const kmac_key_mode_kKmacKeyModeKmac256: kmac_key_mode = 30819;
#[doc = " Enum to specify the KMAC modes that use a key.\n\n This will be used in the `key_mode_t` struct to indicate the mode\n for which the provided key is intended for.\n\n Values are hardened."]
pub type kmac_key_mode = ::core::ffi::c_uint;
#[doc = " Enum to specify the KMAC modes that use a key.\n\n This will be used in the `key_mode_t` struct to indicate the mode\n for which the provided key is intended for.\n\n Values are hardened."]
pub use self::kmac_key_mode as kmac_key_mode_t;
pub const rsa_key_mode_kRsaKeyModeSignPkcs: rsa_key_mode = 18239;
pub const rsa_key_mode_kRsaKeyModeSignPss: rsa_key_mode = 40115;
#[doc = " Enum to specify the RSA modes that use a key.\n\n This will be used in the `key_mode_t` struct to indicate the mode\n for which the provided key is intended for.\n\n Values are hardened."]
pub type rsa_key_mode = ::core::ffi::c_uint;
#[doc = " Enum to specify the RSA modes that use a key.\n\n This will be used in the `key_mode_t` struct to indicate the mode\n for which the provided key is intended for.\n\n Values are hardened."]
pub use self::rsa_key_mode as rsa_key_mode_t;
pub const ecc_key_mode_kEccKeyModeEcdsa: ecc_key_mode = 51866;
pub const ecc_key_mode_kEccKeyModeEcdh: ecc_key_mode = 44285;
pub const ecc_key_mode_kEccKeyModeEd25519: ecc_key_mode = 63467;
pub const ecc_key_mode_kEccKeyModeX25519: ecc_key_mode = 20695;
#[doc = " Enum to specify the ECC modes that use a key.\n\n This will be used in the `key_mode_t` struct to indicate the mode\n for which the provided key is intended for.\n\n Values are hardened."]
pub type ecc_key_mode = ::core::ffi::c_uint;
#[doc = " Enum to specify the ECC modes that use a key.\n\n This will be used in the `key_mode_t` struct to indicate the mode\n for which the provided key is intended for.\n\n Values are hardened."]
pub use self::ecc_key_mode as ecc_key_mode_t;
pub const kdf_key_mode_kKdfKeyModeHMAC: kdf_key_mode = 20074;
pub const kdf_key_mode_kKdfKeyModeKMAC: kdf_key_mode = 10415;
#[doc = " Enum to specify the KDF modes that use a key.\n\n This will be used in the `key_mode_t` struct to indicate the mode\n for which the provided key is intended for.\n\n Values are hardened."]
pub type kdf_key_mode = ::core::ffi::c_uint;
#[doc = " Enum to specify the KDF modes that use a key.\n\n This will be used in the `key_mode_t` struct to indicate the mode\n for which the provided key is intended for.\n\n Values are hardened."]
pub use self::kdf_key_mode as kdf_key_mode_t;
pub const key_mode_kKeyModeAesEcb: key_mode = -1256203817;
pub const key_mode_kKeyModeAesCbc: key_mode = -1256206484;
pub const key_mode_kKeyModeAesCfb: key_mode = -1256222086;
pub const key_mode_kKeyModeAesOfb: key_mode = -1256234337;
pub const key_mode_kKeyModeAesCtr: key_mode = -1256196895;
pub const key_mode_kKeyModeAesGcm: key_mode = -1256243954;
pub const key_mode_kKeyModeAesKwp: key_mode = -1256248335;
pub const key_mode_kKeyModeHmacSha256: key_mode = 426468593;
pub const key_mode_kKeyModeKmac128: key_mode = -412492210;
pub const key_mode_kKeyModeKmac256: key_mode = -412518301;
pub const key_mode_kKeyModeRsaSignPkcs: key_mode = 1337214783;
pub const key_mode_kKeyModeRsaSignPss: key_mode = 1337236659;
pub const key_mode_kKeyModeEcdsa: key_mode = 987155098;
pub const key_mode_kKeyModeEcdh: key_mode = 987147517;
pub const key_mode_kKeyModeEd25519: key_mode = 987166699;
pub const key_mode_kKeyModeX25519: key_mode = 987123927;
pub const key_mode_kKeyModeKdfHmac: key_mode = -108966294;
pub const key_mode_kKeyModeKdfKmac: key_mode = -108975953;
#[doc = " Enum for opentitan crypto modes that use a key.\n\n Denotes the crypto mode for which the provided key is to be used.\n This `key_mode_t` will be a parameter in the `crypto_blinded_key_t`\n and `crypto_unblinded_key_t` structs.\n\n Values are hardened."]
pub type key_mode = ::core::ffi::c_int;
#[doc = " Enum for opentitan crypto modes that use a key.\n\n Denotes the crypto mode for which the provided key is to be used.\n This `key_mode_t` will be a parameter in the `crypto_blinded_key_t`\n and `crypto_unblinded_key_t` structs.\n\n Values are hardened."]
pub use self::key_mode as key_mode_t;
pub const crypto_key_security_level_kSecurityLevelLow: crypto_key_security_level = 61281;
pub const crypto_key_security_level_kSecurityLevelMedium: crypto_key_security_level = 13275;
pub const crypto_key_security_level_kSecurityLevelHigh: crypto_key_security_level = 54461;
#[doc = " Enum to denote key security level.\n\n At high security levels, the crypto library will prioritize\n protecting the key from sophisticated attacks, even at large\n performance costs. If the security level is low, the crypto\n library will still try to protect the key, but may forgo the\n most costly protections against e.g. sophisticated physical\n attacks.\n\n Values are hardened."]
pub type crypto_key_security_level = ::core::ffi::c_uint;
#[doc = " Enum to denote key security level.\n\n At high security levels, the crypto library will prioritize\n protecting the key from sophisticated attacks, even at large\n performance costs. If the security level is low, the crypto\n library will still try to protect the key, but may forgo the\n most costly protections against e.g. sophisticated physical\n attacks.\n\n Values are hardened."]
pub use self::crypto_key_security_level as crypto_key_security_level_t;
pub const crypto_lib_version_kCryptoLibVersion1: crypto_lib_version = 18110;
#[doc = " Enum to denote the crypto library version.\n\n In future updates, this enum will be extended to preserve some\n level of backwards-compatibility despite changes to internal\n details (for example, the preferred masking scheme for blinded\n keys).\n\n Values are hardened."]
pub type crypto_lib_version = ::core::ffi::c_uint;
#[doc = " Enum to denote the crypto library version.\n\n In future updates, this enum will be extended to preserve some\n level of backwards-compatibility despite changes to internal\n details (for example, the preferred masking scheme for blinded\n keys).\n\n Values are hardened."]
pub use self::crypto_lib_version as crypto_lib_version_t;
#[doc = " Struct to represent the configuration of a blinded key."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypto_key_config {
    pub version: crypto_lib_version_t,
    pub key_mode: key_mode_t,
    pub key_length: usize,
    pub hw_backed: hardened_bool_t,
    pub diversification_hw_backed: crypto_const_uint8_buf_t,
    pub exportable: hardened_bool_t,
    pub security_level: crypto_key_security_level_t,
}
#[test]
fn bindgen_test_layout_crypto_key_config() {
    const UNINIT: ::core::mem::MaybeUninit<crypto_key_config> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<crypto_key_config>(),
        48usize,
        concat!("Size of: ", stringify!(crypto_key_config))
    );
    assert_eq!(
        ::core::mem::align_of::<crypto_key_config>(),
        8usize,
        concat!("Alignment of ", stringify!(crypto_key_config))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_key_config),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_mode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_key_config),
            "::",
            stringify!(key_mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_key_config),
            "::",
            stringify!(key_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hw_backed) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_key_config),
            "::",
            stringify!(hw_backed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).diversification_hw_backed) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_key_config),
            "::",
            stringify!(diversification_hw_backed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).exportable) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_key_config),
            "::",
            stringify!(exportable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).security_level) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_key_config),
            "::",
            stringify!(security_level)
        )
    );
}
#[doc = " Struct to represent the configuration of a blinded key."]
pub type crypto_key_config_t = crypto_key_config;
#[doc = " Struct to handle unmasked key type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypto_unblinded_key {
    pub key_mode: key_mode_t,
    pub key_length: usize,
    pub key: *mut u32,
    pub checksum: u32,
}
#[test]
fn bindgen_test_layout_crypto_unblinded_key() {
    const UNINIT: ::core::mem::MaybeUninit<crypto_unblinded_key> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<crypto_unblinded_key>(),
        32usize,
        concat!("Size of: ", stringify!(crypto_unblinded_key))
    );
    assert_eq!(
        ::core::mem::align_of::<crypto_unblinded_key>(),
        8usize,
        concat!("Alignment of ", stringify!(crypto_unblinded_key))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_mode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_unblinded_key),
            "::",
            stringify!(key_mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_unblinded_key),
            "::",
            stringify!(key_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_unblinded_key),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).checksum) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_unblinded_key),
            "::",
            stringify!(checksum)
        )
    );
}
#[doc = " Struct to handle unmasked key type."]
pub type crypto_unblinded_key_t = crypto_unblinded_key;
#[doc = " Struct to handle masked key type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crypto_blinded_key {
    pub config: crypto_key_config_t,
    pub keyblob_length: usize,
    pub keyblob: *mut u32,
    pub checksum: u32,
}
#[test]
fn bindgen_test_layout_crypto_blinded_key() {
    const UNINIT: ::core::mem::MaybeUninit<crypto_blinded_key> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<crypto_blinded_key>(),
        72usize,
        concat!("Size of: ", stringify!(crypto_blinded_key))
    );
    assert_eq!(
        ::core::mem::align_of::<crypto_blinded_key>(),
        8usize,
        concat!("Alignment of ", stringify!(crypto_blinded_key))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).config) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_blinded_key),
            "::",
            stringify!(config)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keyblob_length) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_blinded_key),
            "::",
            stringify!(keyblob_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keyblob) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_blinded_key),
            "::",
            stringify!(keyblob)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).checksum) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(crypto_blinded_key),
            "::",
            stringify!(checksum)
        )
    );
}
#[doc = " Struct to handle masked key type."]
pub type crypto_blinded_key_t = crypto_blinded_key;
pub const kmac_mode_kMacModeKmac128: kmac_mode = 27062;
pub const kmac_mode_kMacModeKmac256: kmac_mode = 61026;
#[doc = " Enum to define KMAC mode.\n\n Values are hardened."]
pub type kmac_mode = ::core::ffi::c_uint;
#[doc = " Enum to define KMAC mode.\n\n Values are hardened."]
pub use self::kmac_mode as kmac_mode_t;
#[doc = " Generic hmac context.\n\n Representation is internal to the hmac implementation; initialize\n with #otcrypto_hmac_init."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hmac_context {
    pub data: [u32; 42usize],
}
#[test]
fn bindgen_test_layout_hmac_context() {
    const UNINIT: ::core::mem::MaybeUninit<hmac_context> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<hmac_context>(),
        168usize,
        concat!("Size of: ", stringify!(hmac_context))
    );
    assert_eq!(
        ::core::mem::align_of::<hmac_context>(),
        4usize,
        concat!("Alignment of ", stringify!(hmac_context))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_context),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " Generic hmac context.\n\n Representation is internal to the hmac implementation; initialize\n with #otcrypto_hmac_init."]
pub type hmac_context_t = hmac_context;
extern "C" {
    #[doc = " Generates a new HMAC or KMAC key.\n\n The caller should allocate and partially populate the blinded key struct,\n including populating the key configuration and allocating space for the\n keyblob. The caller should indicate the length of the allocated keyblob;\n this function will return an error if the keyblob length does not match\n expectations. For hardware-backed keys, the keyblob length is 0 and the\n keyblob pointer may be `NULL`. For non-hardware-backed keys, the keyblob\n should be twice the length of the key. The value in the `checksum` field of\n the blinded key struct will be populated by the key generation function.\n\n @param[out] key Destination blinded key struct.\n @return The result of the key generation operation."]
    pub fn otcrypto_mac_keygen(key: *mut crypto_blinded_key_t) -> crypto_status_t;
}
extern "C" {
    #[doc = " Performs the HMAC-SHA256 function on the input data.\n\n This function computes the required MAC function on the `input_message`\n using the `key` and returns a `tag`.\n\n The caller should allocate 32 bytes of space for the `tag` buffer and set\n its `len` field to 32.\n\n @param key Pointer to the blinded key struct with key shares.\n @param input_message Input message to be hashed.\n @param[out] tag Output authentication tag.\n @return The result of the HMAC operation."]
    pub fn otcrypto_hmac(
        key: *const crypto_blinded_key_t,
        input_message: crypto_const_uint8_buf_t,
        tag: *mut crypto_uint8_buf_t,
    ) -> crypto_status_t;
}
extern "C" {
    #[doc = " Performs the KMAC function on the input data.\n\n This function computes the KMAC on the `input_message` using the `key` and\n returns a `tag` of `required_output_len`. The customization string is passed\n through `customization_string` parameter. If no customization is desired it\n can be empty. The `customization_string` and `required_output_len` is only\n used for KMAC modes and is ignored for the HMAC mode.\n\n The caller should allocate `required_output_len` bytes for the `tag` buffer\n and set the `len` field of `tag` to `required_output_len`. If the user-set\n length and the output length does not match, an error message will be\n returned.\n\n @param key Pointer to the blinded key struct with key shares.\n @param input_message Input message to be hashed.\n @param mac_mode Required operation to be performed.\n @param customization_string Customization string.\n @param required_output_len Required output length, in bytes.\n @param[out] tag Output authentication tag.\n @return The result of the KMAC operation."]
    pub fn otcrypto_kmac(
        key: *const crypto_blinded_key_t,
        input_message: crypto_const_uint8_buf_t,
        kmac_mode: kmac_mode_t,
        customization_string: crypto_const_uint8_buf_t,
        required_output_len: usize,
        tag: *mut crypto_uint8_buf_t,
    ) -> crypto_status_t;
}
extern "C" {
    #[doc = " Performs the INIT operation for HMAC.\n\n Initializes the generic HMAC context. The required HMAC mode is selected\n through the `hmac_mode` parameter. The structure of HMAC context and how it\n populates the required fields based on the HMAC mode are internal to the\n specific HMAC implementation.\n\n The HMAC streaming API supports only the `kMacModeHmacSha256` mode.  Other\n modes are not supported and an error would be returned. The interface is\n designed to be generic to support other required modes in the future.\n\n @param ctx Pointer to the generic HMAC context struct.\n @param key Pointer to the blinded HMAC key struct.\n @return Result of the HMAC init operation."]
    pub fn otcrypto_hmac_init(
        ctx: *mut hmac_context_t,
        key: *const crypto_blinded_key_t,
    ) -> crypto_status_t;
}
extern "C" {
    #[doc = " Performs the UPDATE operation for HMAC.\n\n The update operation processes the `input_message` using the selected\n compression function. The intermediate state is stored in the HMAC context\n `ctx`. Any partial data is stored back in the context and combined with the\n subsequent bytes.\n\n #otcrypto_hmac_init should be called before calling this function.\n\n @param ctx Pointer to the generic HMAC context struct.\n @param input_message Input message to be hashed.\n @return Result of the HMAC update operation."]
    pub fn otcrypto_hmac_update(
        ctx: *mut hmac_context_t,
        input_message: crypto_const_uint8_buf_t,
    ) -> crypto_status_t;
}
extern "C" {
    #[doc = " Performs the FINAL operation for HMAC.\n\n The final operation processes the remaining partial blocks, computes the\n final authentication code and copies it to the `tag` parameter.\n\n #otcrypto_hmac_update should be called before calling this function.\n\n The caller should allocate space for the `tag` buffer, (expected length is\n 32 bytes for HMAC), and set the length of expected output in the `len` field\n of `tag`. If the user-set length and the output length does not match, an\n error message will be returned.\n\n @param ctx Pointer to the generic HMAC context struct.\n @param[out] tag Output authentication tag.\n @return Result of the HMAC final operation."]
    pub fn otcrypto_hmac_final(
        ctx: *mut hmac_context_t,
        tag: *mut crypto_uint8_buf_t,
    ) -> crypto_status_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
